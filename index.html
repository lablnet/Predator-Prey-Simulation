<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Predator-Prey Simulation w/ Grass</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: #000;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 15px;
            border: 2px solid #4CAF50;
            color: #fff;
            z-index: 9999;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.3);
            transition: transform 0.3s ease;
        }
        
        #ui.collapsed {
            transform: translateX(-95%);
        }
        
        #collapseBtn {
            position: absolute;
            right: -30px;
            top: 50%;
            transform: translateY(-50%);
            background: #4CAF50;
            border: none;
            color: white;
            width: 30px;
            height: 60px;
            border-radius: 0 8px 8px 0;
            cursor: pointer;
            font-size: 20px;
            transition: background 0.3s ease;
        }
        
        #collapseBtn:hover {
            background: #45a049;
        }
        
        .config-group {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .config-group label {
            display: inline-block;
            width: 220px;
            font-size: 14px;
            color: #4CAF50;
        }
        
        input[type="number"] {
            width: 80px;
            padding: 5px;
            border: none;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
            font-size: 14px;
        }
        
        input[type="number"]:focus {
            outline: none;
            box-shadow: 0 0 5px #4CAF50;
        }
        
        #updateBtn {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 8px;
            background: #4CAF50;
            color: white;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        #updateBtn:hover {
            background: #45a049;
            transform: scale(1.02);
        }
        
        #startScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            z-index: 10000;
        }
        
        #startBtn {
            padding: 15px 40px;
            font-size: 24px;
            background: #4CAF50;
            border: none;
            border-radius: 50px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        #startBtn:hover {
            background: #45a049;
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.5);
        }
        
        #gameOverScreen {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            z-index: 10000;
            font-size: 48px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        
        .title {
            font-size: 36px;
            color: #4CAF50;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }
        
        #statsPanel {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #4CAF50;
            border-radius: 15px;
            padding: 20px;
            color: white;
            z-index: 10001;
            min-width: 300px;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.5);
        }
        
        #statsPanel h2 {
            color: #4CAF50;
            text-align: center;
            margin-bottom: 20px;
            font-size: 24px;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }
        
        .stat-label {
            color: #4CAF50;
        }
        
        .stat-value {
            color: #fff;
            font-weight: bold;
        }
        
        .game-over-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
        }
        
        .game-over-button {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .game-over-button:hover {
            transform: scale(1.05);
            background: #45a049;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }
    </style>
</head>

<body>
    <div id="startScreen">
        <h1 class="title">Predator-Prey Simulation</h1>
        <button id="startBtn">Start Simulation</button>
    </div>

    <div id="gameOverScreen"></div>

    <div id="ui" style="display: none;">
        <button id="collapseBtn">›</button>
        <div class="config-group">
            <label for="preyCount">Number of Prey:</label>
            <input type="number" id="preyCount" value="10" min="1" max="100" />
        </div>
        <div class="config-group">
            <label for="predatorCount">Number of Predators:</label>
            <input type="number" id="predatorCount" value="3" min="1" max="50" />
        </div>
        <div class="config-group">
            <label for="predatorLifespan">Predator Lifespan (sec):</label>
            <input type="number" id="predatorLifespan" value="15" min="5" max="60" />
        </div>
        <div class="config-group">
            <label for="predatorHungerWarning">Predator Hunger Warning (sec):</label>
            <input type="number" id="predatorHungerWarning" value="10" min="3" max="30" />
        </div>
        <div class="config-group">
            <label for="preyLifespan">Prey Lifespan (sec):</label>
            <input type="number" id="preyLifespan" value="20" min="5" max="60" />
        </div>
        <div class="config-group">
            <label for="preyHungerWarning">Prey Hunger Warning (sec):</label>
            <input type="number" id="preyHungerWarning" value="15" min="3" max="30" />
        </div>
        <button id="updateBtn">Update</button>
    </div>

    <!-- Include THREE.js from a CDN (version may vary) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
    <script>
        /***************************************************************
         * Constants & Globals
         ***************************************************************/
        const WORLD_SIZE = 200; // x, z extent of the world
        const PREY_SPEED = 0.2; // movement speed for prey
        const PREDATOR_SPEED = 0.25; // movement speed for predators
        const DETECTION_RADIUS = 4; // how close to eat
        const NUM_GRASS = 30; // how many grass objects to spawn
        const GRASS_REGROWTH_TIME = 5000; // 5 seconds in milliseconds
        const MAX_GRASS = 40; // Maximum number of grass in the environment

        // Life and hunger timers (will be set from UI)
        let PREDATOR_MAX_HUNGER;
        let PREDATOR_HUNGER_WARNING;
        let PREY_MAX_HUNGER;
        let PREY_HUNGER_WARNING;

        function updateTimersFromUI() {
            // Convert seconds to milliseconds
            PREDATOR_MAX_HUNGER = parseInt(document.getElementById('predatorLifespan').value) * 1000;
            PREDATOR_HUNGER_WARNING = parseInt(document.getElementById('predatorHungerWarning').value) * 1000;
            PREY_MAX_HUNGER = parseInt(document.getElementById('preyLifespan').value) * 1000;
            PREY_HUNGER_WARNING = parseInt(document.getElementById('preyHungerWarning').value) * 1000;
        }

        // Call once at start
        updateTimersFromUI();

        // We'll store objects in these arrays
        let preyArray = [];
        let predatorArray = [];
        let grassArray = [];
        let lastGrassSpawnTime = 0;

        let scene, camera, renderer;
        let clock = new THREE.Clock();

        // Add to Constants section
        let isSimulationRunning = false;
        let gameOverTimeout = null;

        // Add to globals section
        let simulationStartTime = 0;
        let maxPredatorCount = 0;
        let maxPreyCount = 0;
        let totalGrassEaten = 0;
        let totalPreyEaten = 0;

        /***************************************************************
         * Utility Functions
         ***************************************************************/
        function randomBetween(min, max) {
            return Math.random() * (max - min) + min;
        }

        function randomIntBetween(min, max) {
            return Math.floor(randomBetween(min, max));
        }

        /***************************************************************
         * Initialize the scene
         ***************************************************************/
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue background

            // Set up camera
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 100, 200);
            camera.lookAt(0, 0, 0);

            // Set up renderer
            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Enhanced Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(100, 200, 100);
            dirLight.castShadow = true;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 500;
            dirLight.shadow.camera.left = -100;
            dirLight.shadow.camera.right = 100;
            dirLight.shadow.camera.top = 100;
            dirLight.shadow.camera.bottom = -100;
            scene.add(dirLight);

            // Create environment
            createEnvironment();

            // Populate the scene with agents
            createAgents();

            // Events
            window.addEventListener('resize', onWindowResize);
            document.getElementById('updateBtn').addEventListener('click', resetSimulation);

            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        /***************************************************************
         * Create Agents
         ***************************************************************/
        function createAgents() {
            // 1) Create Grass
            createGrass();

            // 2) Create Prey
            const preyCount = parseInt(document.getElementById('preyCount').value, 10);
            createPrey(preyCount);

            // 3) Create Predators
            const predatorCount = parseInt(document.getElementById('predatorCount').value, 10);
            createPredators(predatorCount);
        }

        function createEnvironment() {
            // Ground plane with better texture
            const groundGeo = new THREE.PlaneGeometry(WORLD_SIZE * 0.9, WORLD_SIZE * 0.9);
            const groundMat = new THREE.MeshPhongMaterial({
                color: 0x228b22,
                shininess: 0,
                flatShading: true
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Add boundary walls
            const wallMat = new THREE.MeshPhongMaterial({
                color: 0x8b4513,
                transparent: true,
                opacity: 0.3
            });
            const wallHeight = 10;
            const wallThickness = 2;

            // Create walls
            const walls = [
                // North wall
                new THREE.BoxGeometry(WORLD_SIZE * 0.9, wallHeight, wallThickness),
                // South wall
                new THREE.BoxGeometry(WORLD_SIZE * 0.9, wallHeight, wallThickness),
                // East wall
                new THREE.BoxGeometry(wallThickness, wallHeight, WORLD_SIZE * 0.9),
                // West wall
                new THREE.BoxGeometry(wallThickness, wallHeight, WORLD_SIZE * 0.9)
            ];

            const wallPositions = [
                [0, wallHeight / 2, WORLD_SIZE * 0.45],
                [0, wallHeight / 2, -WORLD_SIZE * 0.45],
                [WORLD_SIZE * 0.45, wallHeight / 2, 0],
                [-WORLD_SIZE * 0.45, wallHeight / 2, 0]
            ];

            walls.forEach((geo, i) => {
                const wall = new THREE.Mesh(geo, wallMat);
                wall.position.set(...wallPositions[i]);
                wall.castShadow = true;
                wall.receiveShadow = true;
                scene.add(wall);
            });
        }

        function createGrass() {
            // Each piece of grass is a small green cylinder
            const grassGeo = new THREE.CylinderGeometry(0.5, 1, 3, 8);
            const grassMat = new THREE.MeshPhongMaterial({
                color: 0x00ff00,
                shininess: 5
            });

            for (let i = 0; i < NUM_GRASS; i++) {
                const grassMesh = new THREE.Mesh(grassGeo, grassMat);
                // Use the same boundary size as walls (WORLD_SIZE * 0.45)
                grassMesh.position.set(
                    randomBetween(-WORLD_SIZE * 0.43, WORLD_SIZE * 0.43), // Slightly inside walls
                    1.5,
                    randomBetween(-WORLD_SIZE * 0.43, WORLD_SIZE * 0.43)
                );
                grassMesh.castShadow = true;
                grassMesh.receiveShadow = true;
                scene.add(grassMesh);
                grassArray.push(grassMesh);
            }
        }

        function updateGrass(currentTime) {
            // Regrow grass periodically if below maximum
            if (currentTime - lastGrassSpawnTime > GRASS_REGROWTH_TIME && grassArray.length < MAX_GRASS) {
                const grassGeo = new THREE.CylinderGeometry(0.5, 1, 3, 8);
                const grassMat = new THREE.MeshPhongMaterial({
                    color: 0x00ff00,
                    shininess: 5
                });

                const grassMesh = new THREE.Mesh(grassGeo, grassMat);
                // Use the same boundary size as walls
                grassMesh.position.set(
                    randomBetween(-WORLD_SIZE * 0.43, WORLD_SIZE * 0.43), // Slightly inside walls
                    1.5,
                    randomBetween(-WORLD_SIZE * 0.43, WORLD_SIZE * 0.43)
                );
                grassMesh.castShadow = true;
                grassMesh.receiveShadow = true;
                scene.add(grassMesh);
                grassArray.push(grassMesh);
                lastGrassSpawnTime = currentTime;
            }
        }

        function keepInBounds(position, velocity) {
            const margin = 1;
            let bounced = false;

            // X-axis bounds (appears as horizontal movement)
            if (position.x > WORLD_SIZE * 0.45 - margin) {
                position.x = WORLD_SIZE * 0.45 - margin;
                velocity.x = -Math.abs(velocity.x);
                bounced = true;
            } else if (position.x < -WORLD_SIZE * 0.45 + margin) {
                position.x = -WORLD_SIZE * 0.45 + margin;
                velocity.x = Math.abs(velocity.x);
                bounced = true;
            }

            // Z-axis bounds (appears as vertical movement)
            if (position.z > WORLD_SIZE * 0.45 - margin) {
                position.z = WORLD_SIZE * 0.45 - margin;
                velocity.z = -Math.abs(velocity.z);
                bounced = true;
            } else if (position.z < -WORLD_SIZE * 0.45 + margin) {
                position.z = -WORLD_SIZE * 0.45 + margin;
                velocity.z = Math.abs(velocity.z);
                bounced = true;
            }

            // If bounced, reduce speed slightly
            if (bounced) {
                velocity.multiplyScalar(0.8);
            }

            // Lock Y position and velocity
            position.y = position.y;
            velocity.y = 0;
        }

        function createPrey(count) {
            // Create a rabbit-like shape
            const preyGroup = new THREE.Group();

            // Body (slightly elongated sphere)
            const bodyGeometry = new THREE.SphereGeometry(1.5, 16, 16);
            const bodyMaterial = new THREE.MeshPhongMaterial({
                color: 0xff69b4
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.scale.z = 1.5;
            preyGroup.add(body);

            // Ears (two tall thin boxes)
            const earGeometry = new THREE.BoxGeometry(0.3, 1.5, 0.3);
            const earMaterial = new THREE.MeshPhongMaterial({
                color: 0xff69b4
            });

            const leftEar = new THREE.Mesh(earGeometry, earMaterial);
            leftEar.position.set(-0.5, 1.5, 0);
            preyGroup.add(leftEar);

            const rightEar = new THREE.Mesh(earGeometry, earMaterial);
            rightEar.position.set(0.5, 1.5, 0);
            preyGroup.add(rightEar);

            for (let i = 0; i < count; i++) {
                const preyInstance = preyGroup.clone();
                preyInstance.position.set(
                    randomBetween(-WORLD_SIZE * 0.8, WORLD_SIZE * 0.8),
                    1.5,
                    randomBetween(-WORLD_SIZE * 0.8, WORLD_SIZE * 0.8)
                );

                preyInstance.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * PREY_SPEED,
                        0, // No vertical movement
                        (Math.random() - 0.5) * PREY_SPEED
                    ),
                    grassEaten: 0,
                    nextEatTime: 0,
                    eatCooldown: 0,
                    lastEatTime: performance.now(), // Track last time prey ate
                    originalColor: new THREE.Color(0xff69b4) // Store original color
                };
                scene.add(preyInstance);
                preyArray.push(preyInstance);
            }
        }

        function createPredators(count) {
            // Create a wolf-like shape
            const predatorGroup = new THREE.Group();

            // Body (elongated sphere)
            const bodyGeometry = new THREE.SphereGeometry(2, 16, 16);
            const bodyMaterial = new THREE.MeshPhongMaterial({
                color: 0x808080
            }); // Grey color
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.scale.z = 1.8;
            predatorGroup.add(body);

            // Head (slightly smaller sphere)
            const headGeometry = new THREE.SphereGeometry(1.2, 16, 16);
            const head = new THREE.Mesh(headGeometry, bodyMaterial);
            head.position.z = 2;
            head.scale.z = 1.3;
            predatorGroup.add(head);

            // Ears (triangular shapes)
            const earGeometry = new THREE.ConeGeometry(0.4, 1, 4);
            const earMaterial = new THREE.MeshPhongMaterial({
                color: 0x808080
            });

            const leftEar = new THREE.Mesh(earGeometry, earMaterial);
            leftEar.position.set(-0.6, 1.5, 2);
            leftEar.rotation.x = -0.3;
            predatorGroup.add(leftEar);

            const rightEar = new THREE.Mesh(earGeometry, earMaterial);
            rightEar.position.set(0.6, 1.5, 2);
            rightEar.rotation.x = -0.3;
            predatorGroup.add(rightEar);

            // Snout
            const snoutGeometry = new THREE.ConeGeometry(0.6, 1.5, 4);
            const snout = new THREE.Mesh(snoutGeometry, bodyMaterial);
            snout.position.z = 3;
            snout.rotation.x = Math.PI / 2;
            predatorGroup.add(snout);

            for (let i = 0; i < count; i++) {
                const predatorInstance = predatorGroup.clone();
                predatorInstance.position.set(
                    randomBetween(-WORLD_SIZE * 0.8, WORLD_SIZE * 0.8),
                    2,
                    randomBetween(-WORLD_SIZE * 0.8, WORLD_SIZE * 0.8)
                );

                predatorInstance.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * PREDATOR_SPEED,
                        0, // No vertical movement
                        (Math.random() - 0.5) * PREDATOR_SPEED
                    ),
                    preyEaten: 0,
                    nextEatTime: 0,
                    eatCooldown: 0,
                    lastEatTime: performance.now(), // Track last time predator ate
                    originalColor: new THREE.Color(0x808080) // Store original color
                };
                scene.add(predatorInstance);
                predatorArray.push(predatorInstance);
            }
        }

        function resetSimulation() {
            updateTimersFromUI(); // Update timers from UI values
            // Remove all existing from scene
            preyArray.forEach((p) => scene.remove(p));
            predatorArray.forEach((pred) => scene.remove(pred));
            grassArray.forEach((g) => scene.remove(g));

            // Clear arrays
            preyArray = [];
            predatorArray = [];
            grassArray = [];

            // Create new sets
            createAgents();
        }

        /***************************************************************
         * Main loop
         ***************************************************************/
        function animate() {
            if (!isSimulationRunning) return;

            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const currentTime = performance.now();

            // Update statistics
            maxPredatorCount = Math.max(maxPredatorCount, predatorArray.length);
            maxPreyCount = Math.max(maxPreyCount, preyArray.length);

            updateGrass(currentTime);
            updatePrey(delta, currentTime);
            updatePredators(delta, currentTime);

            // Check win conditions
            if (preyArray.length === 0) {
                showGameOver('Predators');
            } else if (predatorArray.length === 0) {
                showGameOver('Prey');
            }

            renderer.render(scene, camera);
        }

        /***************************************************************
         * Update Prey
         ***************************************************************/
        function updatePrey(delta, currentTime) {
            for (let i = preyArray.length - 1; i >= 0; i--) {
                const prey = preyArray[i];
                const data = prey.userData;
                let velocity = data.velocity;
                let eatenGrass = false; // Initialize here

                // Calculate hunger time
                const timeSinceLastMeal = currentTime - data.lastEatTime;

                // Check for death by starvation
                if (timeSinceLastMeal > PREY_MAX_HUNGER) {
                    scene.remove(prey);
                    preyArray.splice(i, 1);
                    continue;
                }

                // Show hunger warning through color change
                if (timeSinceLastMeal > PREY_HUNGER_WARNING) {
                    const hungerFactor = 1 - ((timeSinceLastMeal - PREY_HUNGER_WARNING) / (PREY_MAX_HUNGER - PREY_HUNGER_WARNING));
                    const hungerColor = new THREE.Color(0x800080); // Purple color for hungry prey
                    const mixFactor = 1 - hungerFactor;

                    prey.children.forEach(child => {
                        if (child.material) {
                            child.material = child.material.clone();
                            child.material.color.copy(data.originalColor).lerp(hungerColor, mixFactor);
                        }
                    });
                } else {
                    // Reset color if not hungry
                    prey.children.forEach(child => {
                        if (child.material) {
                            child.material = child.material.clone();
                            child.material.color.copy(data.originalColor);
                        }
                    });
                }

                // 1. Check for nearby predators and calculate escape vector
                let escapeVector = new THREE.Vector3(0, 0, 0);
                let nearestPredatorDist = Infinity;
                predatorArray.forEach((predator) => {
                    const dist = prey.position.distanceTo(predator.position);
                    if (dist < DETECTION_RADIUS * 4) { // Increased detection range for predators
                        const away = new THREE.Vector3().subVectors(prey.position, predator.position);
                        away.normalize();
                        // Stronger escape force when predator is closer
                        away.multiplyScalar(1 / (dist * dist));
                        escapeVector.add(away);
                        nearestPredatorDist = Math.min(nearestPredatorDist, dist);
                    }
                });

                // 2. Find nearest grass if hungry and no immediate predator threat
                let seekVector = new THREE.Vector3(0, 0, 0);
                if (nearestPredatorDist > DETECTION_RADIUS * 2 && currentTime >= data.nextEatTime) {
                    let nearestGrass = null;
                    let nearestGrassDist = Infinity;
                    grassArray.forEach((grass) => {
                        const dist = prey.position.distanceTo(grass.position);
                        if (dist < nearestGrassDist) {
                            nearestGrassDist = dist;
                            nearestGrass = grass;
                        }
                    });

                    if (nearestGrass) {
                        seekVector.subVectors(nearestGrass.position, prey.position);
                        seekVector.normalize();
                        // Weaker seek force when grass is far
                        seekVector.multiplyScalar(0.5);
                    }
                }

                // 3. Combine behaviors
                if (escapeVector.length() > 0) {
                    // Prioritize escape if predator is near
                    velocity.add(escapeVector.multiplyScalar(PREY_SPEED * 1.5)); // Temporary speed boost when escaping
                } else {
                    // Add seeking behavior and some random movement
                    velocity.add(seekVector);
                    if (Math.random() < 0.01) {
                        velocity.x += (Math.random() - 0.5) * 0.1;
                        velocity.z += (Math.random() - 0.5) * 0.1;
                    }
                }

                // Limit speed (allow slightly faster speed when escaping)
                const maxSpeed = escapeVector.length() > 0 ? PREY_SPEED * 1.5 : PREY_SPEED;
                if (velocity.length() > maxSpeed) {
                    velocity.setLength(maxSpeed);
                }

                // Move
                prey.position.add(velocity);

                // Boundary check with smoother turning
                if (prey.position.x > WORLD_SIZE / 2 || prey.position.x < -WORLD_SIZE / 2) {
                    velocity.x = -velocity.x * 0.8;
                    prey.position.x = Math.max(Math.min(prey.position.x, WORLD_SIZE / 2), -WORLD_SIZE / 2);
                }
                if (prey.position.z > WORLD_SIZE / 2 || prey.position.z < -WORLD_SIZE / 2) {
                    velocity.z = -velocity.z * 0.8;
                    prey.position.z = Math.max(Math.min(prey.position.z, WORLD_SIZE / 2), -WORLD_SIZE / 2);
                }

                // Attempt to eat grass if cooldown allows and no immediate predator threat
                if (currentTime >= data.nextEatTime && nearestPredatorDist > DETECTION_RADIUS * 2) {
                    let eatenGrass = false;
                    for (let j = 0; j < grassArray.length; j++) {
                        const g = grassArray[j];
                        if (!g) continue;

                        const dist = prey.position.distanceTo(g.position);
                        if (dist < DETECTION_RADIUS) {
                            scene.remove(g);
                            grassArray.splice(j, 1);
                            data.grassEaten += 1;
                            totalGrassEaten += 1; // Track total grass eaten
                            eatenGrass = true;
                            break;
                        }
                    }
                    if (eatenGrass) {
                        data.eatCooldown = randomIntBetween(1, 3) * 1000; // Slightly faster eating (1-3 seconds)
                        data.nextEatTime = currentTime + data.eatCooldown;

                        if (data.grassEaten >= 3) {
                            data.grassEaten = 0;
                            reproducePrey(prey);
                        }
                    }
                }

                // Rotate prey to face movement direction
                if (velocity.length() > 0.01) {
                    prey.rotation.y = Math.atan2(velocity.x, velocity.z);
                }

                // Replace the old boundary check with the new one
                keepInBounds(prey.position, velocity);

                // Update lastEatTime when eating grass
                if (eatenGrass) {
                    data.lastEatTime = currentTime;
                }
            }
        }

        // Create a new prey near the parent
        function reproducePrey(parentPrey) {
            const newPrey = parentPrey.clone();
            newPrey.position.set(
                parentPrey.position.x + randomBetween(-5, 5),
                1.5,
                parentPrey.position.z + randomBetween(-5, 5)
            );

            newPrey.userData = {
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * PREY_SPEED,
                    0, // No vertical movement
                    (Math.random() - 0.5) * PREY_SPEED
                ),
                grassEaten: 0,
                nextEatTime: 0,
                eatCooldown: 0,
                lastEatTime: performance.now(), // Track last time prey ate
                originalColor: new THREE.Color(0xff69b4) // Store original color
            };
            scene.add(newPrey);
            preyArray.push(newPrey);
        }

        /***************************************************************
         * Update Predators
         ***************************************************************/
        function updatePredators(delta, currentTime) {
            // Use index-based loop to safely remove predators
            for (let i = predatorArray.length - 1; i >= 0; i--) {
                const predator = predatorArray[i];
                const data = predator.userData;
                let velocity = data.velocity;

                // Calculate hunger time
                const timeSinceLastMeal = currentTime - data.lastEatTime;

                // Check for death by starvation
                if (timeSinceLastMeal > PREDATOR_MAX_HUNGER) {
                    scene.remove(predator);
                    predatorArray.splice(i, 1);
                    continue;
                }

                // Weaken predator when hungry
                let currentSpeed = PREDATOR_SPEED;
                if (timeSinceLastMeal > PREDATOR_HUNGER_WARNING) {
                    // Reduce speed as hunger increases
                    const hungerFactor = 1 - ((timeSinceLastMeal - PREDATOR_HUNGER_WARNING) / (PREDATOR_MAX_HUNGER - PREDATOR_HUNGER_WARNING));
                    currentSpeed *= Math.max(0.3, hungerFactor); // Don't go below 30% speed

                    // Change color to indicate hunger (fade to red)
                    const hungerColor = new THREE.Color(0xff0000);
                    const mixFactor = 1 - hungerFactor;
                    predator.children.forEach(child => {
                        if (child.material) {
                            child.material = child.material.clone(); // Clone to avoid affecting other predators
                            child.material.color.copy(data.originalColor).lerp(hungerColor, mixFactor);
                        }
                    });
                } else {
                    // Reset color if not hungry
                    predator.children.forEach(child => {
                        if (child.material) {
                            child.material = child.material.clone();
                            child.material.color.copy(data.originalColor);
                        }
                    });
                }

                // Find nearest prey
                let nearestPrey = null;
                let minDistance = Infinity;
                preyArray.forEach((p) => {
                    const dist = predator.position.distanceTo(p.position);
                    if (dist < minDistance) {
                        minDistance = dist;
                        nearestPrey = p;
                    }
                });

                // If a prey is within some range, move closer
                if (nearestPrey && minDistance < 60) {
                    const direction = new THREE.Vector3().subVectors(
                        nearestPrey.position,
                        predator.position
                    );
                    direction.normalize();
                    direction.multiplyScalar(currentSpeed * 0.1); // Use current speed affected by hunger
                    velocity.add(direction);
                } else {
                    // random wandering if no close prey
                    if (Math.random() < 0.01) {
                        velocity.x += (Math.random() - 0.5) * 0.1;
                        velocity.z += (Math.random() - 0.5) * 0.1;
                    }
                }

                // Limit speed based on hunger
                if (velocity.length() > currentSpeed) {
                    velocity.setLength(currentSpeed);
                }

                // Move
                predator.position.add(velocity);

                // Rotate predator to face movement direction
                if (velocity.length() > 0.01) {
                    predator.rotation.y = Math.atan2(velocity.x, velocity.z);
                }

                // Keep within bounds
                keepInBounds(predator.position, velocity);

                // Attempt to eat prey if cooldown allows
                if (currentTime >= data.nextEatTime) {
                    for (let j = 0; j < preyArray.length; j++) {
                        const p = preyArray[j];
                        if (!p) continue;

                        const dist = predator.position.distanceTo(p.position);
                        if (dist < DETECTION_RADIUS) {
                            // Eat prey
                            scene.remove(p);
                            preyArray.splice(j, 1);
                            data.preyEaten += 1;
                            totalPreyEaten += 1; // Track total prey eaten
                            data.lastEatTime = currentTime;

                            // Set a new random cooldown
                            data.eatCooldown = randomIntBetween(1, 5) * 1000;
                            data.nextEatTime = currentTime + data.eatCooldown;

                            // Check reproduction - now only needs 1 prey
                            if (data.preyEaten >= 1) {
                                data.preyEaten = 0;
                                reproducePredator(predator); // This will create 2 new predators
                            }
                            break;
                        }
                    }
                }
            }
        }

        // Create a new predator near the parent
        function reproducePredator(parentPredator) {
            // Create two new predators
            for (let i = 0; i < 2; i++) {
                const newPred = parentPredator.clone();
                newPred.position.set(
                    parentPredator.position.x + randomBetween(-5, 5),
                    2,
                    parentPredator.position.z + randomBetween(-5, 5)
                );
                newPred.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * PREDATOR_SPEED,
                        0, // No vertical movement
                        (Math.random() - 0.5) * PREDATOR_SPEED
                    ),
                    preyEaten: 0,
                    nextEatTime: 0,
                    eatCooldown: 0,
                    lastEatTime: performance.now(), // Reset hunger timer for new predators
                    originalColor: new THREE.Color(0x808080)
                };
                scene.add(newPred);
                predatorArray.push(newPred);
            }
        }

        // Make these functions global by attaching to window
        window.showStats = function(stats) {
            const statsPanel = document.createElement('div');
            statsPanel.id = 'statsPanel';
            statsPanel.innerHTML = `
                <h2>Simulation Statistics</h2>
                <div class="stat-row">
                    <span class="stat-label">Simulation Duration:</span>
                    <span class="stat-value">${stats.totalTime} seconds</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Max Predators:</span>
                    <span class="stat-value">${stats.maxPredators}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Max Prey:</span>
                    <span class="stat-value">${stats.maxPrey}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Total Grass Eaten:</span>
                    <span class="stat-value">${stats.totalGrassEaten}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Total Prey Eaten:</span>
                    <span class="stat-value">${stats.totalPreyEaten}</span>
                </div>
                <div class="game-over-buttons">
                    <button class="game-over-button" onclick="closeStats()">Close</button>
                </div>
            `;
            document.body.appendChild(statsPanel);
            statsPanel.style.display = 'block';
        };

        window.closeStats = function() {
            const statsPanel = document.getElementById('statsPanel');
            if (statsPanel) {
                statsPanel.remove();
            }
        };

        window.restartSimulation = function() {
            closeStats();
            document.getElementById('gameOverScreen').style.display = 'none';
            resetSimulation();
            simulationStartTime = performance.now();
            maxPredatorCount = 0;
            maxPreyCount = 0;
            totalGrassEaten = 0;
            totalPreyEaten = 0;
            isSimulationRunning = true;
        };

        function showGameOver(winner) {
            // Track simulation statistics
            window.lastSimStats = {
                totalTime: Math.floor((performance.now() - simulationStartTime) / 1000),
                maxPredators: maxPredatorCount,
                maxPrey: maxPreyCount,
                totalGrassEaten: totalGrassEaten,
                totalPreyEaten: totalPreyEaten
            };

            const gameOverScreen = document.getElementById('gameOverScreen');
            gameOverScreen.style.display = 'block';

            // Create a styled game over message
            gameOverScreen.innerHTML = `
                <div style="background: rgba(0, 0, 0, 0.8); padding: 30px; border-radius: 15px; border: 2px solid #4CAF50;">
                    <h1 style="color: #4CAF50; margin-bottom: 30px;">${winner} Won!</h1>
                    <div class="game-over-buttons">
                        <button class="game-over-button" onclick="showStats(window.lastSimStats)">View Stats</button>
                        <button class="game-over-button" onclick="restartSimulation()">Play Again</button>
                    </div>
                </div>
            `;

            isSimulationRunning = false; // Stop the simulation

            if (gameOverTimeout) clearTimeout(gameOverTimeout);
        }

        // Add event listeners
        document.getElementById('startBtn').addEventListener('click', startSimulation);

        // Initialize
        init();

        // Add after init()
        function startSimulation() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            isSimulationRunning = true;
            simulationStartTime = performance.now();
            resetSimulation();
            animate();
        }

        // Add after other event listeners
        document.getElementById('collapseBtn').addEventListener('click', function() {
            const ui = document.getElementById('ui');
            const btn = document.getElementById('collapseBtn');
            ui.classList.toggle('collapsed');
            btn.textContent = ui.classList.contains('collapsed') ? '‹' : '›';
        });
    </script>
</body>

</html>